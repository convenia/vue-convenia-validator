{"version":3,"file":"cee-validate.umd.js","sources":["../src/core/fieldBag.ts","../src/core/ruleContainer.ts","../src/utils/is.ts","../src/core/field.ts","../src/rules/alphanumeric.ts","../src/rules/custom.ts","../node_modules/dayjs-ext/src/plugin/customParseFormat/parseFormattedInput.js","../node_modules/dayjs-ext/src/plugin/customParseFormat/index.js","../src/rules/dateFormat.ts","../src/rules/numeric.ts","../src/rules/regex.ts","../src/rules/required.ts","../src/rules/maxLength.ts","../src/rules/minLength.ts","../src/rules/cpf.ts","../src/rules/pis.ts","../src/rules/email.ts","../src/rules/hour.ts","../src/utils/fileValidator.ts","../src/rules/file.ts","../src/core/scopedValidator.ts","../src/index.ts"],"sourcesContent":["import Field from './field'\n\n\nexport default class FieldBag {\n  private _items: Field[]\n\n  constructor (items?: Field[]) {\n    this._items = items || []\n  }\n\n  set items (items: Field | Field[]) {\n    this.push(items)\n  }\n\n  /**\n   * Returns the corresping Field instance, or undefined if not found.\n   *\n   * @param {String} field - The name of the field.\n   * @param {String} scope? - Optional scope of the field.\n   * @returns {Field | undefined} - The Field instance, or undefined if not found.\n   */\n\n  get (field: string, scope?: string): Field | undefined {\n    return this._items.find((item: Field) => scope\n      ? item.name === field && item.scope === scope\n      : item.name === field)\n  }\n\n  /**\n   * Returns all fields registered in the FieldBag\n   *\n   * @param {String} scope? - If present, returns all the fields from that scope\n   * @returns {Array<Field>} - Array of field items\n   */\n\n  all (scope?: string): Array<Field> {\n    return scope\n      ? this._items.filter(f => f.scope === scope)\n      : this._items\n  }\n\n  /**\n   * Check to see if a Field is preseint in the FieldBag, or if a Field\n   * exists in a given scope.\n   *\n   * @param {String} field - The name of the field\n   * @param {String} scope? - Optional scope of the field\n   * @returns {Boolean}\n   */\n\n  has (field: string, scope?: string): boolean {\n    return !!this._items.find((item: Field) => scope\n      ? item.name === field && item.scope === scope\n      : item.name === field)\n  }\n\n  /**\n   * Add a new Field or an array of Field instances to the existing _items\n   * arrays.\n   *\n   * @param {Field | Array<Field>} scope? - If present, returns all the fields\n   * from that scope.\n   * @returns {void}\n   */\n\n  push (item: Field | Field[]): void {\n    // Check if item is already present in the FieldBag instance\n    this._items.push.apply(this._items, Array.isArray(item) ? item : [ item ])\n  }\n\n\n  /**\n   * Removes an existing field from the FieldBag instance.\n   *\n   * @param {String} field - The name of the field\n   * @param {String} scope? - Optional scope of the field\n   * @returns {void}\n   */\n\n  remove (field: string, scope?: string): void {\n    this._items = this._items.filter((item: Field) => scope && item.scope === scope\n      ? item.name !== field\n      : item.name !== field)\n  }\n}\n","import { ValidationRule } from '../types'\n\n\nconst RULES: { [ruleName: string]: ValidationRule } = {}\n\nexport default class RuleContainer {\n  static get rules (): { [ruleName: string]: ValidationRule } {\n    return RULES\n  }\n\n  /**\n   * Get a specific rule from the container.\n   *\n   * @param  {String} ruleName - The name of the rule.\n   * @returns {ValidationRule} - the respective ValidationRule object.\n   */\n  static getRule (ruleName: string): ValidationRule {\n    return RULES[ruleName]\n  }\n\n  /**\n   * Adds a new rule to the container.\n   *\n   * @param ruleName - The name of the rule to be added.\n   * @param rule - The ValidationRule object.\n   * @returns {Void}\n   */\n  static add (ruleName: string, rule: ValidationRule) {\n    RULES[ruleName] = rule\n  }\n\n  /**\n   * Removes a rule from the container.\n   *\n   * @param ruleName - The name of the rule to be removed.\n   * @returns {Void}\n   */\n  static remove(ruleName: string) {\n    delete RULES[ruleName]\n  }\n\n  /**\n   * Checks if a rule exists in the container\n   *\n   * @param ruleName - The name of the rule.\n   * @returns {Boolean}\n   */\n  static has (ruleName: string) {\n    return !!RULES[ruleName]\n  }\n}\n","/**\n * Check value's constructor name.\n * @param {*} value\n * @param {String} constructor\n * @returns {Boolean}\n *\n * @author Vitor Luiz Cavalcanti (https://github.com/VitorLuizC)\n */\n\nexport const is = (value: any, constructor: string): boolean => {\n  return Object.prototype.toString.call(value) === `[object ${constructor}]`\n}\n\nexport default is\n","import FormValidator from '../index'\nimport { is } from '../utils'\n\nimport {\n  FieldItem,\n  FieldFlags,\n  NormalizedRule,\n  FieldValidation\n} from '../types'\n\n\nexport default class Field {\n  private _vm: FormValidator\n  private initialValue: string\n\n  private _flags: FieldFlags = {\n    pristine: false,\n    dirty: false,\n    changed: false,\n    touched: false,\n    valid: false,\n    errors: []\n  }\n\n  public value: any\n  public name: string\n  public scope?: string\n  public el: Element\n  public rules: NormalizedRule[]\n\n  constructor (options: FieldItem) {\n    this.el = options.el\n    this._vm = options.vm\n    this.name = options.name\n    this.value = options.value\n    this.scope = options.scope\n    this.rules = this.mapRules(options.rules)\n    this.initialValue = options.value\n\n    this.init(options)\n  }\n\n  get validate (): any {\n    if (!this._vm || !this._vm.$validator) return () => []\n\n    const validate = this._vm.$validator.validate\n    return validate.bind(this._vm.$validator, this.name, this.scope)\n  }\n\n  get watch (): any {\n    if (!this._vm || !this._vm.$validator) return\n\n    return this._vm.$watch.bind(this._vm)\n  }\n\n  get options (): any {\n    if (!this._vm || !this._vm.$validator) return\n\n    return this._vm.$validator.options\n  }\n\n\n  get flags () { return this._flags }\n\n  get errors () { return this._flags.errors }\n\n  get error () { return this._flags.errors[0] || '' }\n\n  /**\n   * Sets a new value to one of the instance's FieldFlags.\n   *\n   * @param {Keyof FieldFlags} flag - The flag name\n   * @param {Boolean | Array<String>} value - the new value to assigned to the flag\n   * @returns {void}\n   * @author Erik Isidore\n   */\n\n  setFlag (flag: keyof FieldFlags, value: boolean | string[]): void {\n    if (!Object.keys(this._flags).includes(flag)) return\n\n    this._flags[flag] = value\n  }\n\n  /**\n   * Initializes the Field instance.\n   *\n   * @param {FieldItem} options\n   * @returns {void}\n   * @author Erik Isidore\n   */\n\n  init (options: FieldItem): void {\n    if (process.env.NODE_ENV !== 'production' && !this.name)\n      console.warn('CeeValidate: A field declaration is missing a \"name\" attribute')\n\n    this.initFlags()\n    this.addValueListeners()\n  }\n\n  /**\n   * Initializes or resets the Field flags to their default values.\n   *\n   * @returns {void}\n   * @author Erik Isidore\n   */\n\n  initFlags (): void {\n    const flagNames = Object.keys(this._flags) as [keyof FieldFlags]\n    const defaultFlags: FieldFlags = {\n      pristine: !this.value,\n      dirty: !!this.value,\n      touched: false,\n      changed: false,\n      valid: false,\n      errors: []\n    }\n\n    flagNames.forEach((flag: keyof FieldFlags) => {\n      this._flags[flag] = defaultFlags[flag]\n    })\n  }\n\n  /**\n   * Adds event listener for the blur event on the input, so that we can\n   * tell when the input has been `touched` by the user, and attaches a\n   * watcher to the input value, validating it's value whenever it changes.\n   *\n   * @returns {void}\n   * @author Erik Isidore\n   */\n\n  addValueListeners (): void {\n    if (!this.watch || !this.el) return\n\n    const onBlur = () => {\n      if (!this._flags.touched) this._flags.touched = true\n      if (!this.options.noListeners) this.validate()\n    }\n\n    const onInput = (value: any) => {\n      this.value = value\n      this._flags.changed = this.value !== this.initialValue\n\n      if (!this.options.noListeners) this.validate()\n\n      if (!this._flags.dirty) {\n        this._flags.dirty = true\n        this._flags.pristine = false\n      }\n    }\n\n    this.el.addEventListener('focusout', onBlur.bind(this))\n    this.watch(this.scope ? `${this.scope}.${this.name}` : this.name, onInput.bind(this))\n  }\n\n  /**\n   * Receives a FieldValidation entity, which can be\n   *  A string: 'required|dateFormat:DD/MM/YYYY'\n   *  An array of strings: ['required', 'dateFormat:DD/MM/YYYY']\n   *  Or an object: { required: true, dateFormat: 'DD/MM/YYYY' }\n   *\n   * And turns this entity into a array of NormalizedRules, this\n   * array will contain an NormalizedRule object for every rule\n   * found in FieldValidation. A NormalizedRule is simply an\n   * object with the format: { ruleName: <name>, args: [<...>] }\n   *\n   * @param {FieldValidation} rules - The validation rules defined for the field.\n   * @returns {Array<NormalizedRule>} - A array containing a NormalizedRule for\n   * every validation rule defined for the field.\n   *\n   * @author Erik Isidore\n   */\n\n  mapRules (rules: FieldValidation): Array<NormalizedRule> {\n    const stringToRules = (ruleDef: string) => ({\n      ruleName: ruleDef.split(':')[0],\n      args: ruleDef.split(':')[1] && ruleDef.split(':')[1].split(',')\n    })\n\n    const objToRules = (rulesObj: { [rule: string]: any }) =>\n      Object.keys(rulesObj).map(ruleName => ({\n        ruleName,\n        args: !Array.isArray(rulesObj[ruleName])\n          ? [ rulesObj[ruleName] ]\n          : rulesObj[ruleName]\n      }))\n\n    return typeof rules === 'string' && rules.length\n      ? rules.split('|').map(stringToRules)\n      : Array.isArray(rules) ? rules.map(stringToRules)\n      : rules && is(rules, 'Object') ? objToRules(rules as object)\n      : []\n  }\n\n  /**\n   * Resets the field flags and it's value.\n   *\n   * @returns {void}\n   * @author Erik Isidore\n   */\n\n  reset (): void {\n    this.value = this.initialValue\n    this.initFlags()\n  }\n\n  /**\n   * Dynamically updates the field's rules and remaps them.\n   *\n   * @param {FieldValidation} rule - The new rules to be applied\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  setRule (rule: FieldValidation): void {\n    this.rules = this.mapRules(rule)\n  }\n}\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\n/**\n * Checks if all characters in a given value are alphanumeric (letters\n * and numbers), ignores whitespace.\n *\n * @param {String} value - the input value to be tested.\n * @returns {boolean}\n *\n * @author Viniazvd, Erik Isidore\n * @version 0.1\n */\n\nconst rule: ValidationRule = {\n  validate: (value: string): boolean => {\n    if (!value) return true\n\n    return !!value.trim() && /^([0-9a-zA-Z\\s]*)?$/.test(value.trim())\n  },\n  message: 'Deve conter apenas letras e números'\n}\n\nRuleContainer.add('alphanumeric', rule)\nexport default rule\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\n/**\n * Executes a callback or an array of callbacks with `value` as an argument\n * and returns true if every callback passes\n *\n * @param {Any} value - the input value to be validated.\n * @param {Function | Array<Function>} - The callback or array of callbacks\n * to be called on the value.\n * @returns {boolean} - Returns true if every callback passes, false otherwise.\n *\n * @author Viniazvd, Erik Isidore\n * @version 0.1\n */\n\nconst rule: ValidationRule = {\n  validate: (value: any, ...callbacks: Function[]): boolean => {\n    return callbacks.every(f => f(value))\n  },\n  message: 'Campo inválido'\n}\n\nRuleContainer.add('custom', rule)\nexport default rule\n","/* eslint-disable prefer-arrow-callback */\n\nconst formattingTokens = /(\\[[^[]*\\])|([-:/.()\\s]+)|(A|a|YYYY|YY?|MM?|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g\n\nconst match1 = /\\d/ // 0 - 9\nconst match2 = /\\d\\d/ // 00 - 99\nconst match3 = /\\d{3}/ // 000 - 999\nconst match4 = /\\d{4}/ // 0000 - 9999\nconst match1to2 = /\\d\\d?/ // 0 - 99\nconst matchUpperCaseAMPM = /[AP]M/\nconst matchLowerCaseAMPM = /[ap]m/\nconst matchSigned = /[+-]?\\d+/ // -inf - inf\nconst matchOffset = /[+-]\\d\\d:?\\d\\d/ // +00:00 -00:00 +0000 or -0000\nconst matchAbbreviation = /[A-Z]{3,4}/ // CET\n\nconst parseTokenExpressions = {}\nconst parseTokenFunctions = {}\nconst parsers = {}\n\nconst daysInMonths = [\n  31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n]\n\nfunction isLeapYear(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0\n}\n\nfunction checkDay(time) {\n  const { day, month } = time\n  let days\n  if (month === 2) {\n    days = isLeapYear(time.year) ? 29 : 28\n  } else {\n    days = daysInMonths[month - 1]\n  }\n  if (!(day >= 1 && day <= days)) {\n    throw new Error(`Invalid day: \"${day}\".`)\n  }\n}\n\nfunction correctHours(time) {\n  const { afternoon } = time\n  if (afternoon !== undefined) {\n    const { hours } = time\n    if (afternoon) {\n      if (hours < 12) {\n        time.hours += 12\n      }\n    } else if (hours === 12) {\n      time.hours = 0\n    }\n    delete time.afternoon\n  }\n}\n\nfunction makeParser(format) {\n  const array = format.match(formattingTokens)\n  if (!array) {\n    throw new Error(`Invalid format: \"${format}\".`)\n  }\n  const { length } = array\n  for (let i = 0; i < length; i += 1) {\n    const token = array[i]\n    const regex = parseTokenExpressions[token]\n    const parser = parseTokenFunctions[token]\n    if (parser) {\n      array[i] = { regex, parser }\n    } else {\n      array[i] = token.replace(/^\\[|\\]$/g, '')\n    }\n  }\n  return function (input) {\n    const time = {}\n    for (let i = 0, start = 0; i < length; i += 1) {\n      const token = array[i]\n      if (typeof token === 'string') {\n        if (input.indexOf(token, start) !== start) {\n          const part = input.substr(start, token.length)\n          throw new Error(`Expected \"${token}\" at character ${start}, found \"${part}\".`)\n        }\n        start += token.length\n      } else {\n        const { regex, parser } = token\n        const part = input.substr(start)\n        const match = regex.exec(part)\n        if (!match || match.index !== 0) {\n          throw new Error(`Matching \"${regex}\" at character ${start} failed with \"${part}\".`)\n        }\n        const value = match[0]\n        parser.call(time, value)\n        start += value.length\n      }\n    }\n    checkDay(time)\n    correctHours(time)\n    return time\n  }\n}\n\nfunction addExpressionToken(token, regex) {\n  parseTokenExpressions[token] = regex\n}\n\nfunction addParseToken(tokens, property, check) {\n  if (typeof tokens === 'string') {\n    tokens = [tokens]\n  }\n  let callback\n  if (typeof property === 'string') {\n    if (check) {\n      callback = function (input) {\n        const value = +input\n        if (!check(value)) {\n          throw new Error(`Invalid ${property}: \"${input}\".`)\n        }\n        this[property] = value\n      }\n    } else {\n      callback = function (input) {\n        this[property] = +input\n      }\n    }\n  } else {\n    callback = property\n  }\n  for (let i = 0, { length } = tokens; i < length; i += 1) {\n    parseTokenFunctions[tokens[i]] = callback\n  }\n}\n\nfunction offsetFromString(string) {\n  const parts = string.match(/([+-]|\\d\\d)/g)\n  const minutes = +(parts[1] * 60) + +parts[2]\n  const offset = minutes === 0 ? 0 : parts[0] === '+' ? -minutes : minutes // eslint-disable-line no-nested-ternary\n  if (!(offset % 15 === 0 && Math.abs(offset) <= 765)) { // 00:00 - 12:45\n    throw new Error(`Invalid time zone offset: \"${string}\".`)\n  }\n  return offset\n}\n\naddExpressionToken('A', matchUpperCaseAMPM)\naddParseToken(['A'], function (input) {\n  this.afternoon = input === 'PM'\n})\naddExpressionToken('a', matchLowerCaseAMPM)\naddParseToken(['a'], function (input) {\n  this.afternoon = input === 'pm'\n})\n\naddExpressionToken('S', match1)\naddExpressionToken('SS', match2)\naddExpressionToken('SSS', match3)\nfor (let token = 'S', factor = 100; factor >= 1; token += 'S', factor /= 10) {\n  addParseToken(token, function (input) {\n    this.milliseconds = +input * factor\n  })\n}\n\naddExpressionToken('s', match1to2)\naddExpressionToken('ss', match2)\naddParseToken(['s', 'ss'], 'seconds', function (seconds) {\n  return seconds <= 59\n})\n\naddExpressionToken('m', match1to2)\naddExpressionToken('mm', match2)\naddParseToken(['m', 'mm'], 'minutes', function (minutes) {\n  return minutes <= 59\n})\n\naddExpressionToken('H', match1to2)\naddExpressionToken('h', match1to2)\naddExpressionToken('HH', match2)\naddExpressionToken('hh', match2)\naddParseToken(['H', 'HH'], 'hours', function (hours) {\n  return hours <= 23\n})\naddParseToken(['h', 'hh'], 'hours', function (hours) {\n  return hours >= 1 && hours <= 12\n})\n\naddExpressionToken('D', match1to2)\naddExpressionToken('DD', match2)\naddParseToken(['D', 'DD'], 'day')\n\naddExpressionToken('M', match1to2)\naddExpressionToken('MM', match2)\naddParseToken(['M', 'MM'], 'month', function (month) {\n  return month >= 1 && month <= 12\n})\n\naddExpressionToken('Y', matchSigned)\naddExpressionToken('YY', match2)\naddExpressionToken('YYYY', match4)\naddParseToken(['Y', 'YYYY'], 'year')\naddParseToken('YY', function (input) {\n  input = +input\n  this.year = input + (input > 68 ? 1900 : 2000)\n})\n\naddExpressionToken('z', matchAbbreviation)\naddParseToken('z', function (input) {\n  // istanbul ignore next\n  const zone = this.zone || (this.zone = {})\n  zone.abbreviation = input\n})\n\naddExpressionToken('Z', matchOffset)\naddExpressionToken('ZZ', matchOffset)\naddParseToken(['Z', 'ZZ'], function (input) {\n  const zone = this.zone || (this.zone = {})\n  zone.offset = offsetFromString(input)\n})\n\nfunction parseFormattedInput(input, format) {\n  let parser = parsers[format]\n  if (!parser) {\n    parser = makeParser(format)\n    parsers[format] = parser\n  }\n  return parser(input)\n}\n\nexport default parseFormattedInput\n","import parseFormattedInput from './parseFormattedInput'\nimport Utils from '../../utils'\n\nUtils.parseFormattedInput = parseFormattedInput\n\nexport default (o, C) => {\n  const proto = C.prototype\n  const oldParse = proto.parse\n  proto.parse = function (cfg) {\n    const { date: input, format } = cfg\n    if (format) {\n      try {\n        const {\n          year, month, day, hours, minutes, seconds, milliseconds, zone\n        } = parseFormattedInput(input, format)\n        let date\n        if (zone) {\n          const timestamp = Date.UTC(\n            year, month - 1, day,\n            hours || 0, minutes || 0, seconds || 0, milliseconds || 0\n          ) + (zone.offset * 60 * 1000)\n          date = new Date(timestamp)\n        } else {\n          date = new Date(\n            year, month - 1, day,\n            hours || 0, minutes || 0, seconds || 0, milliseconds || 0\n          )\n        }\n        this.$d = date\n      } catch (error) {\n        this.$d = new Date(Number.NaN)\n      }\n      this.init(cfg)\n    } else {\n      oldParse.call(this, cfg)\n    }\n  }\n}\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\nimport { is } from '../utils'\n\nimport dayjs from 'dayjs-ext'\nimport customParseFormat from 'dayjs-ext/plugin/customParseFormat'\n\ndayjs.extend(customParseFormat)\n\n\n/**\n * Validate if the input value produces a valid date and optionally if\n * it follows a given date format.\n *\n * @param {String | Number} value - The value of the input to be validated,\n * if `value` is a String, the validator may also receive a format param to\n * check if the string has the correct format.\n * @param {String} format? - Optional parameter to validate whether the the\n * given input value has the correct format. If given, the value must be a\n * string, otherwise this parameter is completely ignored.\n * @returns {boolean} True if the given value is valid or empty, false otherwise.\n * If you want to check for empty value, use the 'required' rule.\n *\n * @author Erik Isidore\n * @version 0.1\n */\n\nconst rule: ValidationRule = {\n  validate: (value: string | number, format: string = 'DD/MM/YYYY'): boolean => {\n    if (!value) return true\n\n    const options = is(value, 'String') ? { format } : { }\n    const date = dayjs(value, <any>options)\n\n    return date.isValid()\n  },\n  message: 'Data inválida.'\n}\n\nRuleContainer.add('dateFormat', rule)\nexport default rule\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\n/**\n * Checks if all characters in a given value are numeric, ignores whitespace.\n *\n * @param {String} value - The input value to be validated.\n * @returns {Boolean}\n *\n * @author Viniazvd, Erik Isidore\n * @version 0.1\n */\n\nconst rule: ValidationRule = {\n  validate: (value: string): boolean => {\n    if (!value) return true\n\n    return !!value.trim() && /^(\\d+(\\.\\d+)?$)/.test(value.trim())\n  },\n  message: 'Deve conter apenas números.'\n}\n\nRuleContainer.add('numeric', rule)\nexport default rule\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\nimport { is } from '../utils'\n\n/**\n * Receives a value and a regular expression and returns the result of\n * executing the regex on the value.\n *\n * @param {String} value - Input value.\n * @param {Regex} regex - Regular expression object.\n * @returns {boolean}\n *\n * @author Erik Isidore\n * @version 0.1\n */\n\nconst rule: ValidationRule = {\n  validate: (value: string, regex: RegExp): boolean => {\n    if (!value) return true\n\n    if (!is(value, 'String') || !is(regex, 'RegExp')) return false\n\n    return !!value && regex.test(value)\n  },\n  message: 'Formato inválido.'\n}\n\nRuleContainer.add('regex', rule)\nexport default rule\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\n/**\n * Validate if the given value is not empty\n *\n * @param {Any} value - The value of the input to be validated.\n * @returns {boolean} - True if the given value is not empty, false otherwise.\n *\n * @author Viniazvd, Erik Isidore\n * @version 0.1\n */\n\nconst rule: ValidationRule = {\n  validate: (value: any): boolean => {\n    if (Array.isArray(value)) return !!value.length\n    if (typeof value === 'object') return !!Object.keys(value || {}).length\n    if (typeof value === 'string') return !!value.trim().length\n    if (typeof value === 'number') return !!value\n    if (typeof value === 'boolean') return true\n\n    return !!value\n  },\n  message: 'Campo obrigatório.'\n}\n\nRuleContainer.add('required', rule)\nexport default rule\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\ntype ValueType = Array<any> | string | number\n\n/**\n * Checks to see if a given value is bigger than max length, if value\n * is string/array, checks the string length, if it is a number,\n * checks the value itself.\n *\n * @param {Array<any> | String | Number} value - Then given value\n * @param {Number | String} maxLength - the max length.\n * @returns {Boolean} - False if value exceeds max length.\n *\n * @author Erik Isidore\n * @version 0.1\n */\nconst rule: ValidationRule = {\n  validate: (value: ValueType, maxLength: number | string): boolean => {\n    if (typeof value !== 'number' && !value) return true\n\n    if (Array.isArray(value) || typeof value === 'string')\n      return (value || []).length <= maxLength\n\n    return maxLength >= value\n  },\n  message: 'Valor acima do limite.'\n}\n\nRuleContainer.add('maxLength', rule)\nexport default rule","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\ntype ValueType = Array<any> | string | number\n\n/**\n * Checks to see if a given value is bigger than min length, if value\n * is string/array, checks the string length, if it is a number,\n * checks the value itself.\n *\n * @param {Array<any> | String | Number} value - Then given value\n * @param {Number | String} minLength - the min length.\n * @returns {Boolean} - False if value is smaller than min length.\n *\n * @author Erik Isidore\n * @version 0.1\n */\nconst rule: ValidationRule = {\n  validate: (value: ValueType, minLength: number | string): boolean => {\n    if (typeof value !== 'number' && !value) return true\n\n    if (Array.isArray(value) || typeof value === 'string')\n      return (value || []).length >= minLength\n\n    return value >= minLength\n  },\n  message: 'Valor abaixo do limite.'\n}\n\nRuleContainer.add('minLength', rule)\nexport default rule","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\nimport { is } from '../utils'\n\nconst invalidCpfs = Array.from({ length: 10 }, (_, n) => n.toString().repeat(11))\n\n/**\n * Checks if given value is a valid CPF number.\n *\n * @param {String} value - The CPF number to be validated, with or without mask.\n * @returns {Boolean} - wheter it is valid or not\n *\n * @author Vitor Luiz Cavalcanti (https://github.com/VitorLuizC)\n */\nconst rule: ValidationRule = {\n  validate: (value): boolean => {\n    if (!value) return true\n\n    const isInvalid = (cpf: string, rest: number, pos: number): boolean =>\n      rest !== parseInt(cpf.substring(pos, pos + 1))\n\n    const getRest = (sum: number) => sum > 9 ? 0 : sum\n\n    const sumDigit = (cpf: string, digit: number) =>\n      11 - (cpf.substring(0, digit).split('')\n        .reduce((acc, curr, index) => acc += parseInt(curr) * ((digit + 1) - index)\n        , 0) % 11)\n\n    if (!is(value, 'String')) return false\n\n    value = value.replace(/[\\D]/gi, '')\n\n    if (!value.match(/^\\d+$/)) return false\n    if (value.length !== 11) return false\n\n    if (invalidCpfs.includes(value)) return false\n\n    if (isInvalid(value, getRest(sumDigit(value, 9)), 9)) return false\n\n    if (isInvalid(value, getRest(sumDigit(value, 10)), 10)) return false\n\n    return true\n  },\n  message: 'CPF inválido.'\n}\n\nRuleContainer.add('cpf', rule)\nexport default rule\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\nconst rule: ValidationRule = {\n  validate: (value: string): boolean => {\n    if (!value) return true\n\n    const FTAP = '3298765432'\n    const numPis = (value + '').replace(/[^\\d]+/g, '')\n\n    const total = FTAP\n      .split('')\n      .reduce((total, digit, index) => total + (+numPis[index] * +digit), 0)\n\n    let rest: number | string = (total % 11)\n\n    if (rest !== 0) rest = 11 - rest\n\n    if (rest === 10 || rest === 11) rest = (rest + '').slice(1, 2)\n\n    if (+rest !== +(numPis.slice(10,11))) return false\n\n    return true\n  },\n  message: 'Número de PIS inválido'\n}\n\nRuleContainer.add('pis', rule)\nexport default rule","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\n/**\n * Uses a regex defined by the RFC to validate email (http://emailregex.com/)\n *\n * @param {String} value - The input to be validated\n * @return {Boolean}\n *\n * @author Erik Isidore\n */\n\nconst rule: ValidationRule = {\n  validate: (value: string): boolean => {\n    if (!value) return true\n\n    const regex = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    return regex.test((value || '').trim())\n  },\n  message: 'E-mail inválido.'\n}\n\nRuleContainer.add('email', rule)\nexport default rule","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\n/**\n * Uses a regex defined to validate hour\n *\n * ex: https://repl.it/@viniazvd/isValidHour\n *\n * @param {String} value\n * @return {Boolean}\n *\n * @author viniazvd\n * @version 0.1\n */\n\nconst rule: ValidationRule = {\n  validate: (value: string): boolean => {\n    if (!value) return true\n\n    const regex = /^([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?$/\n\n    return regex.test(value)\n  },\n  message: 'Hora inválida'\n}\n\nRuleContainer.add('hour', rule)\nexport default rule\n","export type SizeUnit = 'B' | 'KB' | 'MB' | 'GB'\n\nexport type FileValidatorOpts =\n{ multiple: boolean\n, accept: Array<string>\n, sizeLimit: number | string | null\n, sizeUnit: SizeUnit\n}\n\nconst unitMultipliers: { [unit in SizeUnit]: number } =\n{ 'B':  1\n, 'KB': 1000\n, 'MB': 1000000\n, 'GB': 1000000000\n}\n\n\n/**\n * @param {File} value - The file\n * @param {Array<string>} multiple - Whether or not it is an Array of Files\n * @param {Array<string>} accept - The file types that are accepted\n * @param {Number|String} sizeLimit - Optional size limit for the file (s)\n * @param {SizeUnit} sizeUnit - Determines the unit used for the sizeLimit,\n * one of <'B', 'KB', 'MB' or 'GB'>\n *\n * @author Erik Isidore\n */\n\nexport default\n( file: File\n, accept: Array<string>\n, sizeLimit: number | string | null\n, sizeUnit: SizeUnit = 'KB'\n): boolean => {\n\n  const limitInBytes = sizeLimit && (+sizeLimit * unitMultipliers[sizeUnit]) || 0\n  const fileExt = file.name\n    .substring(file.name.lastIndexOf('.'))\n    .toLowerCase()\n\n  return sizeLimit != null\n    ? accept.includes(fileExt) && file.size <= limitInBytes\n    : accept.includes(fileExt)\n}\n","import RuleContainer from '../core/ruleContainer'\nimport { ValidationRule } from '../types'\n\nimport fileValidator, { FileValidatorOpts } from '../utils/fileValidator'\n\nconst defaultArgs: FileValidatorOpts =\n{ multiple: false\n, accept: []\n, sizeLimit: null\n, sizeUnit: 'KB'\n}\n\n/**\n * @param {File|FileList} value - The file or Array of files (FileList)\n * @param {FileValidatorOpts} options - An object with FileValidatorOptions\n *\n * @author Erik Isidore\n */\n\nconst rule: ValidationRule = {\n  validate: (value: File | FileList, options: FileValidatorOpts): boolean => {\n    if (!value) return true\n\n    const { multiple, accept, sizeLimit, sizeUnit } = { ...defaultArgs, ...options }\n\n    if (multiple) return Array\n      .from((value as FileList))\n      .every((file: File) => fileValidator(file, accept, sizeLimit, sizeUnit))\n\n    return fileValidator(value as File, accept, sizeLimit, sizeUnit)\n  },\n  message: 'Arquivo(s) inválido(s)'\n}\n\nRuleContainer.add('file', rule)\nexport default rule\n","import { Vue as VueComponent } from 'vue-property-decorator'\n\nimport FieldBag from './fieldBag'\nimport Field from './field'\n\nimport RuleContainer from './ruleContainer'\nimport { is } from '../utils'\nimport '../rules'\n\nimport {\n  ValidatorOptionsObject,\n  ValidatorOptions,\n  NormalizedRule,\n  ValidationRule,\n  FormValidation,\n  FieldValidation,\n  FieldFlags,\n  ValidatorOptionsFn,\n} from '../types'\n\n\n// ScopedValidor specific types\n\nexport interface VM extends VueComponent { [dataName: string]: any }\nexport type ScopedFormValidation = { [scope: string]: FormValidation }\nexport type FormTemplate = ScopedFormValidation | FormValidation\n\nexport type FormValidationFlags\n  = { [scope: string]: { [fieldName: string]: FieldFlags } }\n  | { [fieldName: string]: FieldFlags }\n\n\nexport default class ScopedValidator {\n  private _vm: VM\n\n  public fields: FieldBag\n  public scopes: string[] = []\n\n  private _options: ValidatorOptionsObject = {}\n  public validations: FormValidationFlags = {}\n\n\n  constructor (vm: VueComponent) {\n    this._vm = vm\n    this.fields = new FieldBag()\n\n    vm.$nextTick(() => {\n      if (this._vm.$options.validatorOptions)\n        this.options = this._vm.$options.validatorOptions\n\n      if (this._vm.$options.validations)\n        this.init(this._vm.$options.validations)\n    })\n  }\n\n  get options () {\n    return this._options\n  }\n\n  set options (options: any) {\n    this._options = is(options, 'Function')\n      ? options(this._vm)\n      : { ...options }\n  }\n\n  /**\n   * This two following functions are responsible for bootstraping\n   * the ScopedValidation class with the given validation options.\n   * The public init function exists to ensure that whenever we're\n   * bootstraping the ScopedValidator class, the DOM will be accessible\n   * through the _vm.\n   *\n   * @param template - The form validations template object.\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  public init (template: FormTemplate): void {\n    this._vm.$nextTick(this.__init.bind(this, template))\n  }\n\n  private __init (template: FormTemplate): void {\n    this.scopes = Object.keys(template)\n    this.fields.items = this.initFields(template)\n    this.validations = this.mapValidations()\n  }\n\n  /**\n   * Receives a FormTemplate object and maps the fields validation rules\n   * in it to populate the `fields` instance property with Field instances.\n   *\n   * @param {FormTemplate} template - The form or forms validation object.\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  initFields (template: FormTemplate): Field[] {\n    const mapField = (name: string, rules: FieldValidation, scope?: string): Field => {\n      const fieldOptions = {\n        name,\n        rules,\n        scope,\n        vm: this._vm,\n        el: this.getFieldEl(name, scope),\n        value: scope ? this._vm[scope][name] : this._vm[name],\n      }\n\n      return new Field(fieldOptions)\n    }\n\n    // This will map each form scope name to an array of Field instances,\n    // producing an Array of Field arrays, crazy rite? Each field will\n    // have its respective scope assigned to it.\n    const scopes = this.scopes.map((scope: string) => {\n      const formScope: FormValidation = template[scope] as FormValidation\n\n      return Object.keys(formScope)\n        .map(fieldName => mapField(fieldName, formScope[fieldName], scope))\n    })\n\n    return Array.prototype.concat([], ...scopes)\n  }\n\n  /**\n   * Generetes the validation flags object based on the form scopes.\n   *\n   * @returns {FormValidationFlags}\n   *\n   * @author Erik Isidore\n   */\n\n  mapValidations (): FormValidationFlags {\n    const mapFlags = (scope?: string) => this.fields.all(scope)\n      .reduce((acc, field: Field) => ({ ...acc, [field.name]: field.flags }), {})\n\n    const mapFormScopes = (acc: object, scope: string) => ({\n      ...acc,\n      [scope]: mapFlags(scope)\n    })\n\n    return this.scopes.length > 1\n      ? this.scopes.reduce(mapFormScopes, { })\n      : mapFlags()\n  }\n\n  /**\n   * Receives a fieldName and optionally it's scope and returns the HTML\n   * Element corresponding to that field in the DOM.\n   *\n   * @param {String} fieldName - The name of the field\n   * @param {String} scope? - Optional form scope.\n   * @returns {Element} - The first matching element found in the component DOM.\n   *\n   * @author Erik Isidore\n   */\n\n  getFieldEl (fieldName: string, scope?: string): Element {\n    const fieldQuery = scope\n      ? `form[name=\"${scope}\"] [name=\"${fieldName}\"]`\n      : `[name=\"${fieldName}\"]`\n\n    const fields: NodeList = this._vm.$el.querySelectorAll(fieldQuery)\n\n    if (process.env.NODE_ENV !== 'production' && !fields.length)\n      console.warn(`CeeValidate: Field \"${fieldName}\" could not be found in the DOM`)\n\n    return <Element>fields[0]\n  }\n\n  /**\n   * @param {String} fieldName -\n   * @param {String} scope? -\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  validate (fieldName: string, scope?: string): boolean {\n    const field = this.fields.get(fieldName, scope)\n\n    // Field doesn't exist, return false (invalid field)\n    if (!field) return false\n\n    const mapErrors = ({ ruleName, args }: NormalizedRule): string => {\n      const rule: ValidationRule = RuleContainer.getRule(ruleName)\n      const hasError = !rule.validate.apply(null, [field.value, ...(args || [])])\n      const errorMessage = rule.message\n\n      return hasError ? errorMessage : ''\n    }\n\n    const fieldErrors: string[] = field.rules\n      .map(mapErrors)\n      .filter(message => !!message)\n\n    field.setFlag('errors', fieldErrors)\n    field.setFlag('valid', !fieldErrors.length)\n\n    return !fieldErrors.length\n  }\n\n  /**\n   * Executes the validate() method on all Field instances.\n   *\n   * @param {String} scope? -\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  validateAll (scope?: string): boolean {\n    const fieldFlags = this.fields.all(scope)\n      .map((field: Field) => field.validate())\n\n    const isValid = fieldFlags.every(isValid => !!isValid)\n    this.options = { ...(this.options || {}), noListeners: false }\n\n    return isValid\n  }\n\n  /**\n   * Resets all of the fields validation flags.\n   *\n   * @param {String} scope? -\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  reset (scope?: string): void {\n    this.fields.all(scope).forEach((field: Field) => field.reset())\n  }\n\n  /**\n   * Attaches a new field to the validator.\n   *\n   * @param {}\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  attach (field: { name: string, rules: string, scope: string }): void {\n    const newField: Field = new Field({\n      vm: this._vm,\n      name: field.name,\n      rules: field.rules,\n      scope: field.scope,\n      el: this.getFieldEl(field.name, field.scope),\n      value: field.scope ? this._vm[field.scope][field.name] : this._vm[field.name]\n    })\n\n    this.fields.push(newField)\n    this.validations = this.mapValidations()\n  }\n\n  /**\n   * Detaches an existing field from the validator.\n   *\n   * @param {String} field - The name of the field\n   * @param {String} scope? - Optional scope of the field\n   * @returns {void}\n   *\n   * @author Erik Isidore\n   */\n\n  detach (field: string, scope?: string): void {\n    this.fields.remove(field, scope)\n    this.validations = this.mapValidations()\n  }\n\n  /**\n   * Sets the rule of a field and validate it if it has changed.\n   *\n   * @param {Object<name: string, scope: string>} field - Object with name\n   * and scope of the field.\n   * @param {FieldValidation} rules - The rules to be set in the field\n   * @returns {void}\n   */\n  setFieldRule (field: { name: string, scope: string }, rules: FieldValidation): void {\n    const fieldInstance : Field | undefined = this.fields.get(field.name, field.scope)\n    if (!fieldInstance) return\n\n    fieldInstance.setRule(rules)\n\n    if (fieldInstance.flags.changed) fieldInstance.validate()\n  }\n}\n","import { Component, Vue } from 'vue-property-decorator'\n\nimport ScopedValidator from './core/scopedValidator'\n\n// eslint-disable\n@Component\nexport default class FormValidator extends Vue {\n  public $validator: ScopedValidator\n  public $validations: object\n\n  // In the future we'll use this function to pass mixin options\n  // and make some checkings before instantiating the ScopedValidator\n  beforeCreate () {\n    // Get Vue constructor\n    const Vue = this.$options._base\n\n    this.$validator = new ScopedValidator(this)\n\n    // Setup computed properties on the component\n    if (!this.$options.computed) this.$options.computed = {}\n\n    Vue.util.defineReactive(this.$validator, 'validations', this.$validator.validations)\n    this.$options.computed['$validations'] = () => this.$validator.validations\n  }\n\n  // Implement beforeDestroy ()\n}\n"],"names":["rule","formattingTokens","match2","match1to2","matchOffset","parseTokenExpressions","parseTokenFunctions","parsers","daysInMonths","makeParser","format","array","match","Error","length","i","token","regex","parser","replace","input","time","start","indexOf","part","substr","exec","index","value","call","days","year","day","month","checkDay","afternoon","undefined","hours","correctHours","addExpressionToken","addParseToken","tokens","property","check","callback","factor","milliseconds","seconds","minutes","this","zone","abbreviation","offset","string","parts","Math","abs","offsetFromString","o","C","proto","prototype","oldParse","parse","cfg","date","timestamp","Date","UTC","$d","error","Number","NaN","init","tslib_1.__extends","Component","Vue"],"mappings":"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"}